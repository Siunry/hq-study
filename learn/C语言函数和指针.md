# 函数

函数是C语言的最小执行单位. 函数可以将C语言的代码模块化. 

函数在定义的时候: ==高内聚 低耦合==

定义格式:

```
返回值类型    函数名(形式参数列表)   // 定义函数的时候需要的参数: 形式参数
{
    code; // 代码执行语句 函数体
    return 0;  // 表示的是结束这个函数,并且返回一个值.
}

eg: // 定义一个函数,要求函数可以计算两个数字的加法.  3 + 5 
int add(int x, int y)
{
    int sum = x + y;
    return sum;
}

```

函数调用格式:

```
函数名(实际参数列表);
eg: 
    int result = add(10, 20);  // 调用函数的时候传递的参数.
```

==question:  形式参数与实际参数之间的关系?==

==answer :   形式参数是实际参数的一份临时拷贝. 形式参数的改变不会影响到实际参数.==

### 函数的声明

```c
#include <stdio.h>

// function.c这个文件执行的时候，从上往下找到main函数，
// 开始执行main函数。

// 函数的声明
int add(int x, int y);  


int main()
{
    // 开始执行main函数的时候, main函数里面调用了add函数
    // 但是代码从上往下执行的时候没有见过add函数。报错。
    // 解决方式： 提前对 add函数进行声明
    int ret = add(10, 20);

    return 0;
}

// 定义一个计算两个数字之和的函数
int add(int x, int y)
{
    return x + y;
}


```

## 局部变量与全局变量

局部变量:定义在函数内部的变量,就称之为全局变量,出了规定的{}之后,变量会自动消失,被系统回收;如果在定义时没有赋值,则里面的值是随机值.

全局变量: 定义在函数外部的变量,就称之为全局变量. 全局变量的生命周期: 只有程序不结束, 变量永远都存在.  全局变量,如果没有给他值, 则默认为 0.

局部变量与全局变量可以是相同的名字，因为局部变量与全局变量互不干扰。		寻找变量的方式：先局部，然后全局，如果局部变量有这个money，则不去全局寻找了.

==总结:==     

局部变量: 定义在函数内部 ,生命周期 出了定义变量的{}. 默认值: 随机值    

全局变量: 定义在函数外部. 生命周期: 整个程序结束,    默认值:  0     

寻找变量方式: 先局部,然后全局. 

# 指针(4/8字节)

## 相关概念

### 地址

在arm架构的计算机中,内存是一块儿连续的空间,使用数字对内存的每一个字节进行编号.这个编号就称之为==地址==.

### 指针变量

本质是一个变量,但指针变量里面的值全部都是==指针==.

### 指针

指针是一个数据类型.用来定义变量或者标识指向某块地址.



在工作与生活中,不对这三个概念进行区分,统称为==指针==.

# 指针相关运算符

## &(取地址运算符)

获取变量的地址.

对于多字节类型的地址,取的是变量的==首地址==

## *(取值运算符)

​	左值:等号左边的值就称之为左值.

​	右值:等号右边的值就称之为右值(没有等号,默认为右值).

运算规则:   *指针

- *指针是左值的时候:获取指针指向的空间,并且将右值赋值给这个空间.
- *指针是右值的时候:获取指针指向空间里面的值.

​														==*指针 = 变量名==



## 指针定义	

指针定义格式:

​		<数据类型>  *  指针名  = value;		

​		`int *p;`						==(指针的类型是: int * 指针指向的类型是int类型)==

- 此时的*没有任何意义,标识p是一个指针,并无左右值之分.

​		`p = &number;`			将number的地址赋值给变量p.也可以看作  p指向 number.

​		指针指向变量之后,就可以通过指针对变量进行修改

​		`*p = 200;`						( *p ) == number = 200;

​		指针指向变量后,可以通过指针访问到指向的变量内容.

- 指针只能指向已分配了的地址,不能手动指向分配的地址.
- 指针指向一块未知的空间,称这样的指针为野指针.
  - 危害: 
    1. 段错误,
    2. 野指针随机指向空间已经被分配,通过野指针对其数据进行修改.
  - 避免:
    1. 在书写指针的时候就对指针进行赋值.
    2. 在赋值时直接赋值给NULL
       1. `int *p = NULL;`	(NULL 就是数字0)相当于指针指向0地址空间处,0地址空间不允许读写,报段错误

![image-20240801210021826](C:\Users\Somnium\AppData\Roaming\Typora\typora-user-images\image-20240801210021826.png)



## 指针变量在内存中的大小

32位系统中指针大小都是4个字节.

64位系统中指针的大小都是8个字节

### 指针类型的作用

在内存中拿去指定大小的字节数.

#### 指针解引用的大小字节数

基础概念:

- 解引用:通过指针使用指针所指向的空间.解引用(*指针)

-  int*  char

- 指针指向的类型:指针变量存放的地址里面的数据类型

  ![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB5c404fae9e15b6166b7be512bc757878/WEBRESOURCE86e2e30761fcb16589c5882597be5acf/66110)

### 指针的运算

指针运算:指针变量里面存放的地址进行运算

​					既然是使用的地址进行运算,那么运算就是有限的



指针运算方式:

```
	1. 算数运算: ==`++  --  +   -`==	
   - 指针 + /- 1,
     - 移动其指向类型大小的字节数.
   - 指针 = / - 地址 :   
     - 地址 + 地址没有意义,所以不做讨论.
     - 地址 - 地址表示两个元素之间相差的位置
```

​		2.关系运算: ==<   >(一般在数组中使用)   ==  !===



### 指针强制类型转换

- (into*)p

  

​																					

### 指针与数组

#### 数组名

数组名是一个==地址常量==.

数组名值  =  数组的首元素地址  =  整个数组的地址

![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB30554a1749e84ef1ab0a180f597bf1f7/WEBRESOURCE30460bb686a2428e2d473a2e0e1cd54e/66159)

### 数组名传参

