# 函数

函数是C  语言的最小执行单位. 函数可以将C语言的代码模块化. 

函数在定义的时候: ==高内聚 低耦合==

定义格式:

```
返回值类型    函数名(形式参数列表)   // 定义函数的时候需要的参数: 形式参数
{
    code; // 代码执行语句 函数体
    return 0;  // 表示的是结束这个函数,并且返回一个值.
}

eg: // 定义一个函数,要求函数可以计算两个数字的加法.  3 + 5 
int add(int x, int y)
{
    int sum = x + y;
    return sum;
}

```

函数调用格式:

```
函数名(实际参数列表);
eg: 
    int result = add(10, 20);  // 调用函数的时候传递的参数.
```

==question:  形式参数与实际参数之间的关系?==

==answer :   形式参数是实际参数的一份临时拷贝. 形式参数的改变不会影响到实际参数.==

## 函数的声明

```c
#include <stdio.h>

// function.c这个文件执行的时候，从上往下找到main函数，
// 开始执行main函数。

// 函数的声明
int add(int x, int y);  


int main()
{
    // 开始执行main函数的时候, main函数里面调用了add函数
    // 但是代码从上往下执行的时候没有见过add函数。报错。
    // 解决方式： 提前对 add函数进行声明
    int ret = add(10, 20);

    return 0;
}

// 定义一个计算两个数字之和的函数
int add(int x, int y)
{
    return x + y;
}


```

### 局部变量与全局变量

局部变量:定义在函数内部的变量,就称之为全局变量,出了规定的{}之后,变量会自动消失,被系统回收;如果在定义时没有赋值,则里面的值是随机值.

全局变量: 定义在函数外部的变量,就称之为全局变量. 全局变量的生命周期: 只有程序不结束, 变量永远都存在.  全局变量,如果没有给他值, 则默认为 0.

局部变量与全局变量可以是相同的名字，因为局部变量与全局变量互不干扰。		寻找变量的方式：先局部，然后全局，如果局部变量有这个money，则不去全局寻找了.

==总结:==     

局部变量: 定义在函数内部 ,生命周期 出了定义变量的{}. 默认值: 随机值    

全局变量: 定义在函数外部. 生命周期: 整个程序结束,    默认值:  0     

寻找变量方式: 先局部,然后全局. 

# 指针 (4/8字节)

## 相关概念

#### 地址

在arm架构的计算机中,内存是一块儿连续的空间,使用数字对内存的每一个字节进行编号.这个编号就称之为==地址==.

#### 指针变量

本质是一个变量,但指针变量里面的值全部都是==指针==.

#### 指针

指针是一个数据类型.用来定义变量或者标识指向某块地址.



在工作与生活中,不对这三个概念进行区分,统称为==指针==.

## 指针相关运算符

### &(取地址运算符)

获取变量的地址.

对于多字节类型的地址,取的是变量的==首地址==

### *(取值运算符)

​	左值:等号左边的值就称之为左值.

​	右值:等号右边的值就称之为右值(没有等号,默认为右值).

运算规则:   *指针

- *指针是左值的时候:获取指针指向的空间,并且将右值赋值给这个空间.
- *指针是右值的时候:获取指针指向空间里面的值.

​														==*指针 = 变量名==



## 指针定义	

指针定义格式:

​		<数据类型>  *  指针名  = value;		

​		`int *p;`						==(指针的类型是: int * 指针指向的类型是int类型)==

- 此时的*没有任何意义,标识p是一个指针,并无左右值之分.

​		`p = &number;`			将number的地址赋值给变量p.也可以看作  p指向 number.

​		指针指向变量之后,就可以通过指针对变量进行修改

​		`*p = 200;`						( *p ) == number = 200;

​		指针指向变量后,可以通过指针访问到指向的变量内容.

- 指针只能指向已分配了的地址,不能手动指向分配的地址.

- 指针指向一块未知的空间,称这样的指针为野指针.
  - 危害: 
    1. 段错误,
    2. 野指针随机指向空间已经被分配,通过野指针对其数据进行修改.
    
  - 避免:
    1. 在书写指针的时候就对指针进行赋值.
    
    2. 在赋值时直接赋值给NULL
       1. `int *p = NULL;`	(NULL 就是数字0)相当于指针指向0地址空间处,0地址空间不允许读写,报段错误
       
          ==空指针不能赋值==

![image-20240801210021826](C:\Users\Somnium\AppData\Roaming\Typora\typora-user-images\image-20240801210021826.png)



## 指针变量在内存中的大小

32位系统中指针大小都是4个字节.

64位系统中指针的大小都是8个字节

## 指针类型的作用

在内存中拿去指定大小的字节数.

## 指针解引用的大小字节数

基础概念:

- 解引用:通过指针使用指针所指向的空间.解引用(*指针)

-  int*  char

- 指针指向的类型:指针变量存放的地址里面的数据类型

  ![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB5c404fae9e15b6166b7be512bc757878/WEBRESOURCE86e2e30761fcb16589c5882597be5acf/66110)

## 指针的运算

指针运算:指针变量里面存放的地址进行运算

​					既然是使用的地址进行运算,那么运算就是有限的



指针运算方式:

```
	1. 算数运算: ==`++  --  +   -`==	
   - 指针 + /- 1,
     - 移动其指向类型大小的字节数.
   - 指针 = / - 地址 :   
     - 地址 + 地址没有意义,所以不做讨论.
     - 地址 - 地址表示两个元素之间相差的位置
```

​		2.关系运算: ==<   >(一般在数组中使用)   ==  !===



## 指针强制类型转换

- (into*)p

  

​																					

## 指针与数组

### 数组名

数组名是一个==地址常量==.

数组名值  =  数组的首元素地址  =  整个数组的地址

![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB30554a1749e84ef1ab0a180f597bf1f7/WEBRESOURCE30460bb686a2428e2d473a2e0e1cd54e/66159)

### 数组名传参



# 指针与字符串

### 字符串定义

-  正常:  char str[] = "hello world";
- 特殊定义: char *str = "hello world";    //定义一个指针,指针指向字符串第一个字符的地址

### 地址空间

```
#include <stdio.h>


int main()
{
    int number  = 10;

    // 打印number变量的地址: 理论上 0xffff ffff > 地址 >  0  

    printf("number 地址: %p\n", &number);  //number 地址: 0x7ffc8455f634

    // number 打印出的地址 远远大于 4G的物理内存，
    // 说明程序使用的地址一定不是真正意义是的物理内存  --->
    // 使用的都是虚拟地址。
    return 0;
}
```



![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB2f8862715b67b29cb096fece3b93d98c/WEBRESOURCEea3920cd6fd04b83859a2bfd632b7afc/66208)

s![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB2f8862715b67b29cb096fece3b93d98c/WEBRESOURCEefb705617a9d93acdbaca212a0a17428/66210)



虚拟内存优点:

1. 物理意义上防止野指针的使用

2. 每个程序都认为自己有独立的用户空间(0~3G),方便管理程序.

   





### 字符串与指针总结

```c
虚拟内存空间4G 
   3G ~ 4G: 内核区 
   0G ~ 3G: 用户区
       栈区:
       堆区
       静态区:
           .bss段
           .data段
           .ro段
           .text代码

char *src = "hello world";  // src:栈区   "hello world" .ro段 
char dest[20] = "hello world"; 

*src = 'H';  // error. src是栈区的可以进行随便修改, 但是 *src 在readonly.
dest[0] = "H"; // right: dest是一个字符串,在栈区. 栈区是可以修改的. 

src++; // right: src是一个变量, 变量是可以++, src++ 移动到e的位置.  
dest++; //  error: 数组名是一个地址常量, 是不可以++ / -- 这些运算的.

src="abcdefg"; //src是一个指针. 相当于将.ro段的 abcdefg的首地址a,存放到src这个变量中. 
dest="abcdefg";  // error: dest是一个常量, 不可以直接进行赋值.  strcpy函数. 

*src++; //  right: 单目运算符从右向左进行计算. 先计算++,但是由于是后置++ 所以后生效.
*dest++; // error: dest是常量, 是不可以进行++的.
```



## 数组指针

概念:数组指针本质上是一个指针,指针指向的内容是一个数组.(指针里面存放的是一个指针整个数组的地址)

### 定义格式

- ==<数据类型>(*指针名) [成员个数]= value==
  - <数据类型>------->数组里面每一个成员所属类型
  - [成员个数]--------->数组成员个数
  - value---------------->整个数组的地址

eg:

- `int (*p)[10] = &arr;`

### 数组指针与二维数组

```c
#include<stdio.h>

int main()
{

	int arr[3][4] = {
						{1,2,3,4},
						{5,6,7,8},
						{9,10,11,12},
					};
	int (*p)[4] = arr;

	for(int i =0;i<3;i++)
	{
		for(int j=0;j<4;j++)
		{
			printf("%d ",(*(p+i))[j]);
		}
	}
	return 0;
}

```

### 数组名加与减.

### 一维数组



![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB2f8862715b67b29cb096fece3b93d98c/WEBRESOURCEa619b73fb1fc22a48f9f2a9b2d8b6e30/66289)

### 二维数组

二维数组的首元素是一个一维数组.

![img](https://note.youdao.com/yws/public/resource/fcaf003cf95f3c16d1e971c8bc89356b/xmlnote/WEB2f8862715b67b29cb096fece3b93d98c/WEBRESOURCEe013019a8b5e92be90b97b2135012ade/66291)

### 指针数组

- 简介

  指针数组本质上是一个数组,只不过数组里面的每一个元素都是一个指针.

- 定义格式

  ```c
  <成员类型> *数组名 [成员个数];
  	|		 |		  
  	|		 |-------------------->标识符
  	|----------------------------->数组里面存放的指针指向的数据类型
  	
  	
  	 int a = 10, b = 20, c = 30 , d = 40;
      // 定义一个数组, 数组里面存放的是这几个元素的地址
      int *arr[4] = {&a, &b, &c, &d};  // 使用一个变量来,控制4个变量
  ```
  
  指针数组一般用来配合字符串使用.

### main函数传递参数

#### 添加main快捷键

1. 切换到用户家目录
2. cd /home/linux/.vim/snippets
3. 修改C语言快捷方式
4. vim c.snippets



### 二级指针

变量 :  存放常量的空间

一级指针:  存放变量的地址. 

二级指针:  存放一级指针的地址的指针.

三级指针:  存放二级指针的地址的指针.

==注意:   不要进行跨界存储:  一级指针只能存变量的地址.  二级指针只能存一级指针的地址.....==

```c
int number = 10;   // 变量的定义 
int *p  = &number;  // 一级指针的定义 
int **pp = &p;      // 二级指针的定义 
int ***ppp = &pp;   // 三级指针的定义 
int ****pppp = &ppp;  //四级指针的定义.
```



![image-20240806191225208](C:\Users\Somnium\AppData\Roaming\Typora\typora-user-images\image-20240806191225208.png)



```c
格式: 
    <数据类型> ** 标识符 = value; 
        |           |       |---------> 一级指针的地址.
        |           |-----------------> 二级指针的名称        
        | ----------------------------> 一级指针指向的数据的类型.
eg:
    int number  = 10; 
    int *p = &number;  // 一级指针.
    int **q = &p;      // 二级指针.
```



![image-20240806191300692](C:\Users\Somnium\AppData\Roaming\Typora\typora-user-images\image-20240806191300692.png)

### 传值与传地址

传值: 函数传参的时候,传递的是变量的值. 在函数内部是没有办法改变原来实参的内容.  

传地址: 函数传递参数的时候,传递的是实参的地址. 在新的函数中,可以通过地址对原来的实参 进行操作.

# 指针函数

指针函数: 本质上是一个函数, 只不过函数的返回值是一个指针.  

eg:  strcpy 函数原型:  char * strcpy(char *dest, char *src);

==**注意:  函数指针不可以返回局部变量的地址.**==

## 函数指针

- 函数指针: 本质上是一个指针, 函数指针里面存放的内容是函数的地址.
- 函数名: 本质 上就是函数的地址.

### 定义

```c
格式:
    返回值类型   (*标识符) (函数形式参数类型);
        |            |          | ------------> 函数的形式参数,只写类型, 不写形式参数的名称
        |            | -----------------------> 指针名称        
        | ------------------------------------> 函数返回值类型.
            
	//通过指针p去调用function函数；
    int result = (*p)(10, 20);//*指针-->变量名*p = functionfunction(10, 20)   (*p)(10, 20)      
    printf("result = %d\n", result);
	//特殊调用
	int ret = p(30, 40);
```



## 回调函数

- 回调函数
  - 函数指针作为函数的参数,并且在这个函数中,通过函数指针调用了该函数,那么这个函数就称之为回调函数.
  
  ```
  void ace()
  {
      printf("i am 艾斯奥特曼\n");
  }
  // 定义一个函数。 函数的功能就是进行自我介绍
  void info(void (*p)()  )
  {
      // 通过指针p去调用到 传递过来的函数。
      p();
  }
  
  int main(int argc, const char *argv[])
  {
      info(ace);//对info函数输入指针调用ace函数
  }
  ```
  
  

### 函数指针数组

函数指针数组    本质上是一个数组, 这个数组里面的存放的每一个元素都是一个函数指针. 

```c
格式:
    <数据类型>  (*标识符[常量]) (参数类型); 
         |         |     |        | ------> 函数指针的参数类型   
         |         |     |----------------> 数组成员个数     
         |         |----------------------> 数组名称   
         |--------------------------------> 函数返回值类型.
             
     // 定义一个数组， 数组里面存放的元素都是函数指针。
    
    int (*arr[4])(int,int)    = {add, sub, mul, div};  
	// add  sub mul  div 都是函数名， 都是函数的指针。
    
	// 定义一个指针， 指针指向函数指针数组。 （了解)
	int (*op_function [4])(int , int ) = {add, sub, mul, div};
    int (*(*p)[4])(int , int ) =  &op_function;
         
```

